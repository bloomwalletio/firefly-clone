// Copyright 2021 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

import { MessageHandler } from './MessageHandler';
import { Account } from './Account';

import type {
    AccountId,
    Auth,
    EventType,
    AccountManagerOptions,
    CreateAccountPayload,
    NodeInfoWrapper,
    ClientOptions,
    AccountSyncOptions,
    WalletEvent,
    LedgerNanoStatus,
    Event,
    EventId,
    Node,
    EventStatus,
    GenerateAddressOptions,
} from './types';

/** The AccountManager class. */
export async function AccountManager(options: AccountManagerOptions) {
    
    let id: AccountId
    
    let messageHandler = await MessageHandler(options);

    /**
     * Backup the data to a Stronghold snapshot.
     */
    async function backup(destination: string, password: string): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'backup',
            payload: {
                destination,
                password,
            },
        });
    }

    /**
     * Transform a bech32 encoded address to a hex encoded address
     */
    async function bech32ToHex(bech32Address: string): Promise<string> {
        const response = await messageHandler.sendMessage({
            cmd: 'bech32ToHex',
            payload: bech32Address,
        });
        return JSON.parse(response).payload;
    }

    /**
     * Change the Stronghold password.
     */
    async function changeStrongholdPassword(
        currentPassword: string,
        newPassword: string,
    ): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'changeStrongholdPassword',
            payload: {
                currentPassword,
                newPassword,
            },
        });
    }

    /**
     * Clear the Stronghold password from memory.
     */
    async function clearStrongholdPassword(): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'clearStrongholdPassword',
        });
    }

    /**
     * Create a new account.
     */
    async function createAccount(payload: CreateAccountPayload): Promise<Account> {
        const response = await messageHandler.sendMessage({
            cmd: 'createAccount',
            payload,
        });
        return new Account(JSON.parse(response).payload, messageHandler);
    }

    /**
     * Destroy the AccountManager and drop its database connection.
     */
     function destroy(): void {
        messageHandler.destroy();
    }

    async function deregisterParticipationEvent(eventId: EventId): Promise<void> {
        await this.messageHandler.sendMessage({
            cmd: 'deregisterParticipationEvent',
            payload: {
                eventId,
            },
        });
    }

    /**
     * Emit a provided event for testing of the event system.
     */
    async function emitTestEvent(event: WalletEvent): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'emitTestEvent',
            payload: event,
        });
    }

    /**
     * Generate a random BIP39 mnemonic.
     */
    async function generateMnemonic(): Promise<string> {
        const response = await messageHandler.sendMessage({
            cmd: 'generateMnemonic',
        });
        return JSON.parse(response).payload;
    }

    /**
     * Get an account by its alias or index.
     */
    async function getAccount(accountId: AccountId): Promise<Account> {
        const response = await messageHandler.sendMessage({
            cmd: 'getAccount',
            payload: accountId,
        });

        const account = new Account(
            JSON.parse(response).payload,
            messageHandler,
        );

        return account;
    }

    /**
     * Get all account indexes.
     */
    async function getAccountIndexes(): Promise<number[]> {
        const response = await messageHandler.sendMessage({
            cmd: 'getAccountIndexes',
        });

        return JSON.parse(response).payload;
    }

    /**
     * Get all accounts.
     */
    async function getAccounts(): Promise<Account[]> {
        const response = await messageHandler.sendMessage({
            cmd: 'getAccounts',
        });

        const { payload } = JSON.parse(response);

        const accounts: Account[] = [];

        for (const account of payload) {
            accounts.push(new Account(account, messageHandler));
        }
        return accounts;
    }

    /**
     * Generate an address without storing it.
     */
     async function generateAddress(
        accountIndex: number,
        internal: boolean,
        addressIndex: number,
        options?: GenerateAddressOptions,
        bech32Hrp?: string,
    ): Promise<string> {
        const response = await this.messageHandler.sendMessage({
            cmd: 'generateAddress',
            payload: {
                accountIndex,
                internal,
                addressIndex,
                options,
                bech32Hrp,
            },
        });
        return JSON.parse(response).payload;
    }

    /**
     * Get the node info.
     */
    async function getNodeInfo(url?: string, auth?: Auth): Promise<NodeInfoWrapper> {
        const response = await messageHandler.sendMessage({
            cmd: 'getNodeInfo',
            payload: { url, auth },
        });
        return JSON.parse(response).payload;
    }

    /**
     * Get the status for a Ledger Nano.
     */
    async function getLedgerNanoStatus(): Promise<LedgerNanoStatus> {
        const response = await messageHandler.sendMessage({
            cmd: 'getLedgerNanoStatus',
        });
        return JSON.parse(response).payload;
    }

    async function getParticipationEvent(eventId: EventId): Promise<Event> {
        const response = await this.messageHandler.sendMessage({
            cmd: 'getParticipationEvent',
            payload: {
                eventId,
            },
        });
        return JSON.parse(response).payload;
    }

    async function getParticipationEvents(): Promise<Event[]> {
        const response = await this.messageHandler.sendMessage({
            cmd: 'getParticipationEvents',
        });
        return JSON.parse(response).payload;
    }

    async function getParticipationEventStatus(eventId: EventId): Promise<EventStatus> {
        const response = await this.messageHandler.sendMessage({
            cmd: 'getParticipationEventStatus',
            payload: {
                eventId,
            },
        });
        return JSON.parse(response).payload;
    }

    /**
     * Transform hex encoded address to bech32 encoded address. If no bech32Hrp
     * is provided, the AccountManager will attempt to retrieve it from the
     * NodeInfo. If this does not succeed, it will default to the Shimmer testnet bech32Hrp.
     */
    async function hexToBech32(hex: string, bech32Hrp?: string): Promise<string> {
        const response = await messageHandler.sendMessage({
            cmd: 'hexToBech32',
            payload: { hex, bech32Hrp },
        });
        return JSON.parse(response).payload;
    }

    /**
     * Check if the Stronghold password has been set.
     */
    async function isStrongholdPasswordAvailable(): Promise<boolean> {
        const response = await messageHandler.sendMessage({
            cmd: 'isStrongholdPasswordAvailable',
        });
        return JSON.parse(response).payload;
    }

    /**
     * Listen to wallet events with a callback. An empty array will listen to all possible events.
     */
     async function listen(
        eventTypes: EventType[],
        callback: (error: Error, result: string) => void,
    ): Promise<void> {
        return await messageHandler.listen(eventTypes, callback);
    }

    /**
     * Clear the callbacks for provided events. An empty array will clear all listeners.
     */
     function clearListeners(eventTypes: EventType[]): void {
        return messageHandler.clearListeners(eventTypes);
    }

    /**
     * Find accounts with unspent outputs.
     */
    async function recoverAccounts(
        accountStartIndex: number,
        accountGapLimit: number,
        addressGapLimit: number,
        syncOptions: AccountSyncOptions,
    ): Promise<Account[]> {
        const response = await messageHandler.sendMessage({
            cmd: 'recoverAccounts',
            payload: {
                accountStartIndex,
                accountGapLimit,
                addressGapLimit,
                syncOptions,
            },
        });

        const accounts: Account[] = [];

        for (const account of JSON.parse(response).payload) {
            accounts.push(new Account(account, messageHandler));
        }
        return accounts;
    }

    /**
     * Delete the latest account.
     */
    async function removeLatestAccount(): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'removeLatestAccount',
        });
    }

    async function registerParticipationEvent(
        eventId: EventId,
        nodes: Node[],
    ): Promise<Event> {
        const response = await this.messageHandler.sendMessage({
            cmd: 'registerParticipationEvent',
            payload: {
                eventId,
                nodes,
            },
        });

        return JSON.parse(response).payload;
    }

    /**
     * Restore a backup from a Stronghold file
     * Replaces client_options, coin_type, secret_manager and accounts. Returns an error if accounts were already created
     * If Stronghold is used as secret_manager, the existing Stronghold file will be overwritten. If a mnemonic was
     * stored, it will be gone.
     */
    async function restoreBackup(source: string, password: string): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'restoreBackup',
            payload: {
                source,
                password,
            },
        });
    }

    /**
     * Set ClientOptions.
     */
    async function setClientOptions(options: ClientOptions): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'setClientOptions',
            payload: options,
        });
    }

    /**
     * Set the Stronghold password.
     */
    async function setStrongholdPassword(password: string): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'setStrongholdPassword',
            payload: password,
        });
    }

    /**
     * Set the interval after which the Stronghold password gets cleared from memory.
     */
    async function setStrongholdPasswordClearInterval(
        intervalInMilliseconds?: number,
    ): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'setStrongholdPasswordClearInterval',
            payload: intervalInMilliseconds,
        });
    }

    /**
     * Start the background syncing process for all accounts.
     */
    async function startBackgroundSync(
        options?: AccountSyncOptions,
        intervalInMilliseconds?: number,
    ): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'startBackgroundSync',
            payload: {
                options,
                intervalInMilliseconds,
            },
        });
    }

    /**
     * Stop the background syncing process for all accounts.
     */
    async function stopBackgroundSync(): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'stopBackgroundSync',
        });
    }

    /**
     * Store a mnemonic in the Stronghold snapshot.
     */
    async function storeMnemonic(mnemonic: string): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'storeMnemonic',
            payload: mnemonic,
        });
    }

    /**
     * Verify if a mnemonic is a valid BIP39 mnemonic.
     */
    async function verifyMnemonic(mnemonic: string): Promise<void> {
        await messageHandler.sendMessage({
            cmd: 'verifyMnemonic',
            payload: mnemonic,
        });
    }

    return {
        id,
        MessageHandler,
        backup,
        bech32ToHex,
        changeStrongholdPassword,
        clearStrongholdPassword,
        createAccount,
        destroy,
        deregisterParticipationEvent,
        emitTestEvent,
        generateMnemonic,
        generateAddress,
        getAccount,
        getAccountIndexes,
        getAccounts,
        getNodeInfo,
        getLedgerNanoStatus,
        getParticipationEvent,
        getParticipationEvents,
        getParticipationEventStatus,
        hexToBech32,
        isStrongholdPasswordAvailable,
        listen,
        clearListeners,
        recoverAccounts,
        removeLatestAccount,
        registerParticipationEvent,
        restoreBackup,
        setClientOptions,
        setStrongholdPassword,
        setStrongholdPasswordClearInterval,
        startBackgroundSync,
        stopBackgroundSync,
        storeMnemonic,
        verifyMnemonic
    }
}
